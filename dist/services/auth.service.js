import { AppDataSource } from '../config/database.js';
import { User } from '../entities/user.entity.js';
import argon2 from 'argon2';
import jwt from 'jsonwebtoken';
import { ConflictError, UnauthorizedError } from '../utils/errors.js';
// Recommended: define once at module level
const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
    throw new Error('JWT_SECRET is not defined in environment variables');
}
export class AuthService {
    constructor() {
        this.userRepo = AppDataSource.getRepository(User);
    }
    async register({ email, password }) {
        const existing = await this.userRepo.findOneBy({
            email: email.toLowerCase().trim(),
        });
        if (existing) {
            throw new ConflictError('Email already exists');
        }
        const passwordHash = await argon2.hash(password, {
            type: argon2.argon2id,
            memoryCost: 19456,
            timeCost: 2,
            parallelism: 1,
        });
        const user = this.userRepo.create({
            email: email.toLowerCase().trim(),
            passwordHash,
        });
        const savedUser = await this.userRepo.save(user);
        const { passwordHash: _, ...safeUser } = savedUser;
        return safeUser;
    }
    async login({ email, password }) {
        const user = await this.userRepo.findOneBy({
            email: email.toLowerCase().trim(),
        });
        if (!user) {
            throw new UnauthorizedError('Invalid credentials');
        }
        // Now safe because passwordHash is string (not string | undefined)
        const isValid = await argon2.verify(user.passwordHash, password);
        if (!isValid) {
            throw new UnauthorizedError('Invalid credentials');
        }
        const token = jwt.sign({ id: user.id, email: user.email }, JWT_SECRET, // TS infers string
        { expiresIn: process.env.JWT_EXPIRES_IN ?? '1h' });
        const { passwordHash: _, ...safeUser } = user;
        return { user: safeUser, token };
    }
    async findById(id) {
        const user = await this.userRepo.findOneBy({ id });
        if (!user)
            return null;
        const { passwordHash: _, ...safeUser } = user;
        return safeUser;
    }
}
